/*

	Demo of glcd library with AVR8 microcontroller
	
	Tested on a custom made PCB (intended for another project)

	See ../README.md for connection details

*/

#include <avr/io.h>
#include "glcd/glcd.h"
#include <avr/interrupt.h>
#include <stdio.h>
#include <stdlib.h>
#include "glcd/fonts/Liberation_Sans15x21_Numbers.h"
#include "glcd/fonts/font5x7.h"
#include <avr/pgmspace.h>
#include <util/delay.h>


#define TASTER_R !(PIND&(1<<PD6)) && (entprell==0)
#define TASTER_G !(PIND&(1<<PD5)) && (entprell==0)
#define F_CPU 16000000UL  // 1 MHz

/* Function prototypes */

volatile uint8_t kreis=0;
volatile uint8_t sek=0;
volatile uint8_t min=0;
volatile uint8_t h=0;
uint8_t x_ball=3;
uint8_t y_ball=42;
uint8_t x_recht=45;
uint8_t y_recht=34;
uint8_t richtung=0;
uint8_t taster_rot=0;
uint8_t taster_grun=0;
uint8_t entprell=0;
uint8_t beginn=0;

ISR(TIMER0_OVF_vect)
{
	static uint8_t ISR_zaehler=0;
	static uint8_t ISR_ms_100=0;
	static uint8_t ISR_sek=0;
	static uint8_t ISR_min=0;
	static uint8_t ISR_h=0;

	
	TCNT0 = 0;
	ISR_zaehler++;//zähler hochrechnen
	kreis++;
	if(kreis==4)	
	{
		if(x_ball==3)
		{
			richtung=0;
		}
		
		if((x_ball==42) && (y_ball>y_recht) && (y_ball<y_recht+16))
		{
			richtung=1;
		}
		
		if(x_ball==47)
		{
			if((y_ball<y_recht) || (y_ball>y_recht+16))
			{
				beginn=1;
			}
		}
		
	
		if(richtung==0)
		{
			x_ball++;
		}
		
		if(richtung==1)
		{
			x_ball--;
		}
		
		if(beginn==1)
		{
			glcd_fill_circle(y_ball, x_ball-1, 3, WHITE);
			x_ball=0;
			beginn=0;
		}
		
		kreis=0;
	}
	
	if(entprell!=0)
		{
			entprell--;
		}
	
	if(ISR_zaehler==12)
	{
		ISR_ms_100++; //100 milisekunden hochrechnen
		
		if(ISR_ms_100==10)
		{
			sek++; //sekunden hochrechnen
			ISR_sek++;
			ISR_ms_100=0; //milisekunden auf 0 setzen
		}
		
		if(ISR_sek==60)
		{
			min++; //minuten hochrechnen
			ISR_min++;
			ISR_sek=0; //sekunden auf 0 setzen
			sek=0;
		}
		
		if(ISR_min==60)
		{
			h++; //stunden hochrechnen
			ISR_h++;
			ISR_min=0; //minuten auf 0 setzen
			min=0;
		}
		
		ISR_zaehler=0; //zähler auf 0 setzen
	}
	
}

static void setup(void);

static void setup(void)
{
	/* Set up glcd, also sets up SPI and relevent GPIO pins */
	glcd_init();
}

//uint8_t ms, ms10,ms100,sec,min,entprell, state;



const unsigned char batman[] PROGMEM= 
{ 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0xc0, 0xc0, 0xe0, 0xe0, 0xf0, 0xf0, 0xf8, 
	0xf8, 0xf8, 0xfc, 0xfc, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 
	0xff, 0xe7, 0x83, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0xc0, 0xfe, 0xfc, 0xf8, 0xf8, 0xfc, 0xfe, 0xc0, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x83, 
	0xe7, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfc, 0xfc, 
	0xf8, 0xf8, 0xf8, 0xf0, 0xf0, 0xe0, 0xe0, 0xc0, 0xc0, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xe0, 
	0x70, 0x78, 0x3c, 0x3e, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 
	0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 
	0xfe, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfe, 
	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 
	0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3e, 0x3c, 0x78, 0x70, 
	0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x0f, 
	0x3f, 0x7f, 0x3f, 0x3f, 0x1f, 0x1f, 0x0f, 0x0f, 0x0f, 0x0f, 
	0x0f, 0x1f, 0x1f, 0x1f, 0x3f, 0x3f, 0x7f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0x7f, 0x3f, 0x3f, 0x1f, 0x1f, 0x1f, 0x0f, 0x0f, 0x0f, 
	0x0f, 0x1f, 0x1f, 0x1f, 0x3f, 0x3f, 0x7f, 0x3f, 0x0f, 0x03, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x3f, 0xff, 0xff, 0x3f, 
	0x0f, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00
	};
	
uint8_t taster(uint8_t tast_nr) // Flankenerkennung
{
	static uint8_t pegelg=0;		//Variabeln initialisieren
	static uint8_t pegelaltg=0;
	static uint8_t pegelr=0;
	static uint8_t pegelaltr=0;
	uint8_t rueckgabe=0;

	switch(tast_nr)
	{
		case 1: 	if(TASTER_R) //taster gedrückt
					{
						pegelr=1;
						
						if(pegelaltr==0)
						{
							rueckgabe=1;
						}
					}
					else
					{
						pegelr=0;
						rueckgabe=0;
					}
						
						
						
					pegelaltr=pegelr;
					break;
					
		case 2:		if(TASTER_G) //taster gedrückt
					{
						pegelg=1;
						
						if(pegelaltg==0)
						{
							rueckgabe=1;
						}
					}
					else
					{
						pegelg=0;
						rueckgabe=0;
					}
						
						
						
					pegelaltg=pegelg; // Beide Pegel gleichsetzen
					break;
	}
	return rueckgabe; //rueckgabe wird zurückgegeben
}



	
	
int main(void)
{	

	DDRB=0xFF; //Ganzer Port B als Ausgang 
	PORTB=0x00; //Alle LEDs ausschalten

	TCCR0A		= 0x00; 			//Timer Konfigurieren
	TCCR0B		= 0x04; 			//Timer Konfigurieren
	TIMSK0		|= (1 << TOIE0);	//Timer Konfigurieren
	TIFR0	|= (1 << TOV0);			//Timer Konfigurieren
	sei();
	
	/* Backlight pin PL3, set as output, set high for 100% output */
	DDRB |= (1<<PB2);
	PORTB |= (1<<PB2);
	
	DDRC |= (1<<PC3);
	PORTC |= (1<<PC3);
	
	DDRD &= ~(1<<PD5);
	PORTD |= (1<<PD5);
	
	DDRD &= ~(1<<PD6);
	PORTD |= (1<<PD6);

    sei();
    // enable interrupts
	
	setup();
	
	glcd_clear();
	glcd_write();
	
	

		
	// Display
	glcd_tiny_set_font(Font5x7,5,7,32,127);
	glcd_clear_buffer();
	
	
	while(1) 
	{
		glcd_fill_rect(y_recht, x_recht, 16, 2, WHITE);
		
		if(TASTER_G)
		{
			taster_grun++;
			entprell=2;

		}
		
		if(TASTER_R)
		{
			taster_rot++;
			entprell=2;

		}
		
		
		if(taster_grun>0)
		{
			y_recht++;
			taster_grun=0;
			
			if(y_recht>68)
			{
				y_recht=68;
			}
		}
		
		if(taster_rot>0)
		{
			y_recht--;
			taster_rot=0;
			
			if(y_recht<1)
			{
				y_recht=1;
			}
		}
		
		
		glcd_fill_rect(y_recht, x_recht, 16, 2, BLACK);
		
		if(richtung==0)
		{
			glcd_fill_circle(y_ball, x_ball-1, 3, WHITE);
		}
		
		if(richtung==1)
		{
			glcd_fill_circle(y_ball, x_ball+1, 3, WHITE);
		}
	
//		glcd_draw_string_xy(0, 0, "Justin Rhyner");
		
		glcd_fill_circle(y_ball, x_ball, 3, BLACK);
		
		glcd_draw_rect(0, 0, 84, 48, BLACK);
		
		
		
		glcd_write();
	}//End of while
	
	//---------------------------------------------
	
	return 0;
}//end of main
